{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"architecture/","title":"Architecture","text":""},{"location":"architecture/#components","title":"Components","text":"<p>Structure of the library includes several components, such as:</p> <ul> <li><code>Request</code></li> <li><code>RequestMap</code></li> <li><code>RequestHandler</code></li> <li><code>Response</code></li> <li><code>Event</code></li> <li><code>EventMap</code></li> <li><code>EventHandler</code></li> <li><code>MessageBroker</code></li> <li><code>EventEmitter</code></li> <li><code>Container</code></li> <li><code>Dispatcher</code></li> <li><code>Middleware</code></li> <li><code>MiddlewareChain</code></li> <li><code>Mediator</code></li> </ul>"},{"location":"architecture/#components-dependency","title":"Components Dependency","text":""},{"location":"architecture/#request-related-system-side","title":"Request-related system side:","text":"<pre><code>classDiagram\n    Dispatcher &lt;|-- Mediator\n    MiddlewareChain &lt;|-- Dispatcher\n    RequestMap &lt;|-- Dispatcher\n\n    class RequestMap{\n        +bind(request_type, handler_type) None\n        +get(request_type) Type[RequestHandler]\n    }\n    class MiddlewareChain{\n        +set(chain) None\n        +add(middleware) None\n        +wrap(handler) WrappedHandler\n    }\n    class Dispatcher{\n        +RequestMap request_map\n        +Container container\n        +MiddlewareChain middleware_chain\n        +dispatch(request) DispatchResult\n    }\n    class Mediator{\n        +RequestMap request_map\n        +Container container\n        +MiddlewareChain middleware_chain\n        +EventEmitter event_emitter\n        +send(request) Response\n    }</code></pre>"},{"location":"architecture/#event-related-system-side","title":"Event-related system side:","text":"<pre><code>classDiagram\n    EventEmitter &lt;|-- Mediator\n    EventMap &lt;|-- EventEmitter\n    MessageBroker &lt;|-- EventEmitter\n\n    class EventMap{\n        +bind(event_type, handler_type) None\n        +get(event_type) List[Type[EventHandler]]\n    }\n    class MessageBroker{\n        +send_message(message) None\n    }\n    class EventEmitter{\n        +EventMap event_map\n        +Container container\n        +MessageBroker message_broker\n        +emit(event) None\n    }\n    class Mediator{\n        +RequestMap request_map\n        +Container container\n        +MiddlewareChain middleware_chain\n        +EventEmitter event_emitter\n        +send(request) Response\n    }</code></pre>"},{"location":"architecture/#components-interaction","title":"Components Interaction","text":""},{"location":"architecture/#request-dispatching","title":"Request dispatching:","text":"<pre><code>graph TB\n    Client-- JoinMeetingCommand --&gt;Mediator--&gt;Dispatcher-- JoinMeetingCommand --&gt;JoinMeetingCommandHandler</code></pre> <p>Description:</p> <ol> <li>Client sends JoinMeetingCommand to Mediator.</li> <li>Mediator sends this command to Dispatcher.</li> <li>Dispatcher gets its handler and builds instance of command handler class via Container.</li> <li>Dispatcher handles command using certain method of its handler.</li> <li>Dispatcher returns DispatchResult to Mediator, which contains published events and Response.</li> </ol>"},{"location":"architecture/#event-dispatching","title":"Event dispatching:","text":"<pre><code>graph TB\n    Dispatcher-- UserJoinedEvent --&gt;Mediator--&gt;EventEmitter-- UserJoinedEvent --&gt;UserJoinedEventHandler</code></pre> <p>Description:</p> <ol> <li>Dispatcher returns DispatchResult to Mediator, which contains published events and Response.</li> <li>Mediator sends published event to EventEmitter.</li> <li>Event gets its handler and builds instance of event handler class via Container.</li> <li>EventEmitter handles command using certain method of its handler.</li> </ol>"},{"location":"contributing/","title":"Contributing","text":"<p>This page discribes how to contribute to Diator.</p>"},{"location":"contributing/#requirements","title":"Requirements","text":"<ul> <li>Linux, since all development proccess adapted for Linux machines.</li> <li>supported Python version (e.g. Python 3.10 or Python 3.11).</li> <li>Redis, since we have integration and end-to-end tests.</li> </ul>"},{"location":"contributing/#environment-preparation","title":"Environment preparation","text":"<ol> <li>fork the repository</li> <li>clone the forked repository</li> <li> <p>create a Python virtual environment in the desired location:</p> <pre><code>python -m venv .venv\n</code></pre> </li> <li> <p>activate environment:</p> <pre><code>source .venv/bin/activate\n</code></pre> </li> <li> <p>install dev dependencies:</p> <pre><code>pip install -e .[\"test\"]\n</code></pre> </li> <li> <p>run unit tests:</p> <pre><code>make test-unit\n</code></pre> </li> </ol>"},{"location":"contributing/#formatters","title":"Formatters","text":"<p>We are using the following linters:</p> <ul> <li>black</li> <li>flake8</li> <li>vulture</li> <li>mypy</li> <li>isort</li> </ul> <p><code>Makefile</code> supports a task to run linters:</p> <pre><code>make check-linting\n</code></pre>"},{"location":"contributing/#how-to-name-branches","title":"How to name branches","text":"<p>It doesn't matter, as long as branch names don't contain anything that violates the Code of Conduct included in the project's repository. As a general rule of thumb, branch names should have a descriptive name, or refer the number of an issue in their name.</p>"},{"location":"di/","title":"Dependency Injection","text":"<p>Dependency Injection pattern (DI) separates the concerns of constructing objects and using them, leading to loosely coupled programs.</p>"},{"location":"di/#usage-in-diator","title":"Usage in Diator","text":"<p>In Diator, dependency injection is implemented via special <code>Container</code> class, which is literally an abstraction over various dependency injection frameworks. This allows developers to easily manage dependencies and decouple components, leading to more modular and maintainable code. Currently, Diator supports two popular DI-frameworks, adriangb/di and Neoteroi/rodi, but we plan to expand support for other frameworks in the future.</p>"},{"location":"di/#neoteroirodi","title":"Neoteroi/rodi","text":"<p>Configure by 2 steps:</p> <ol> <li> <p>Setup dependencies:</p> <pre><code>from rodi import Container\n\n\ndef configure_di():\n    container = Container()\n\n    container.register(UserJoinedEventHandler)\n    container.register(JoinMeetingRoomCommandHandler)\n</code></pre> </li> <li> <p>Integrate with Diator:</p> <pre><code>from rodi import Container\n\nfrom diator.container.rodi import RodiContainer\ndef configure_di() -&gt; RodiContainer:\n    container = Container()\n\n    container.register(UserJoinedEventHandler)\n    container.register(JoinMeetingRoomCommandHandler)\n\nrodi_container = RodiContainer()\nrodi_container.attach_external_container(container)\nreturn rodi_container\n</code></pre> </li> </ol>"},{"location":"di/#adriangbdi","title":"adriangb/di","text":"<p>Configure by 2 steps:</p> <ol> <li> <p>Setup dependencies:</p> <pre><code>from di import Container, bind_by_type\nfrom di.dependent import Dependent\n\n\ndef configure_di():\n    container = Container()\n\n    container.bind(bind_by_type(Dependent(UserJoinedEventHandler, scope=\"request\"), UserJoinedEventHandler))\n    container.bind(\n        bind_by_type(\n            Dependent(JoinMeetingRoomCommandHandler, scope=\"request\"),\n            JoinMeetingRoomCommandHandler,\n        )\n    )\n</code></pre> </li> <li> <p>Integrate with Diator:</p> <pre><code>from di import Container, bind_by_type\nfrom di.dependent import Dependent\n\nfrom diator.container.di import DIContainer\ndef configure_di() -&gt; DIContainer:\n    container = Container()\n\n    container.bind(bind_by_type(Dependent(UserJoinedEventHandler, scope=\"request\"), UserJoinedEventHandler))\n    container.bind(\n        bind_by_type(\n            Dependent(JoinMeetingRoomCommandHandler, scope=\"request\"),\n            JoinMeetingRoomCommandHandler,\n        )\n    )\n\ndi_container = DIContainer()\ndi_container.attach_external_container(container)\nreturn di_container\n</code></pre> </li> </ol>"},{"location":"di/#recources","title":"Recources","text":"<ul> <li> <p>Introduction IoC, DIP, DI and IoC Container</p> </li> <li> <p>Dependency Injection Principles, Practices, and Patterns</p> </li> <li> <p>.NET dependency injection</p> </li> </ul>"},{"location":"events/","title":"Events","text":"<p>Event represents a fact that has occurred in the application. It typically represents a significant change in the application's state that is of interest to other parts of the application or external systems.</p> <p>There are several types of events:</p> <ul> <li>Domain event</li> <li>Notification event</li> <li>Event-carried state transfer (ECST)</li> </ul> <p>Domain events are handled by specialized handlers, whereas Notification and ECST events are sent to message brokers.</p>"},{"location":"events/#publishing-event","title":"Publishing Event","text":"<p>Events are published in the <code>CommandHandler</code> side like below:</p> <pre><code>from diator.requests import RequestHandler\nfrom diator.events import EventHandler\n\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meeting_api: MeetingAPI) -&gt; None:\n        self._meeting_api = meeting_api\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        await self._meeting_api.join(request.meeting_id, request.user_id)\nself._events.append(\nUserJoinedDomainEvent(user_id=request.user_id, timestamp=datetime.utcnow(), meeting_id=request.meeting_id)\n)\nself._events.append(\nUserJoinedNotificationEvent(user_id=request.user_id)\n)\n</code></pre>"},{"location":"events/#domain-event","title":"Domain Event","text":"<p>Domain event is a message describing a significant event that has occurred in the business domain.</p> <p>Example:</p> <pre><code>from diator.events import DomainEvent\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass UserJoinedDomainEvent(DomainEvent):\n    user_id: int = dataclasses.field()\n    meeting_id: int = dataclasses.field()\n    timestamp: datetime = dataclasses.field()\n</code></pre> <p>This event type is handled by its event handler.</p>"},{"location":"events/#event-handler","title":"Event Handler","text":"<p>Event Handler is a component responsible for processing an Domain Event that has occurred in the application:</p> <pre><code>from diator.events import EventHandler\n\n\nclass UserJoinedDomainEventHandler(EventHandler[UserJoinedDomainEvent]):\n    def __init__(self, meeting_api: MeetingAPI) -&gt; None:\n        self._meeting_api = meeting_api\n\n    async def handle(self, event: UserJoinedDomainEvent) -&gt; None:\n        await self._meeting_api.notify(event.meeting_id, \"New user joined!\")\n</code></pre>"},{"location":"events/#mapping","title":"Mapping","text":"<p>In order to map each domain event to its handler, you can use <code>EventMap</code> as below:</p> <pre><code>from diator.requests import EventMap\n\n\nevent_map = EventMap()\nevent_map.bind(UserJoinedDomainEvent, UserJoinedDomainEventHandler)\nevent_map.bind(UserJoinedDomainEvent, AnotherUserJoinedDomainEventHandler)\n</code></pre>"},{"location":"events/#notification-event","title":"Notification Event","text":"<p>Notification Event is a message regarding a change in the business domain that other components will react to.</p> <p>Example:</p> <pre><code>from diator.events import NotificationEvent\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass UserJoinedNotificationEvent(NotificationEvent):\n    user_id: int = dataclasses.field()\n</code></pre>"},{"location":"events/#ecst-event","title":"ECST Event","text":"<p>Event-carried state transfer (ECST) is a message that notifies subscribers about changes in the producer\u2019s internal state.</p> <p>Example:</p> <pre><code>from diator.events import ECSTEvent\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass UserChangedECSTEvent(ECSTEvent):\n    user_id: int = dataclasses.field()\n    new_username: str = dataclasses.field()\n</code></pre>"},{"location":"events/#event-emitter","title":"Event Emitter","text":"<p><code>EventEmitter</code> is a component, that is responsible for events dispatching. It decides whether to send event to message broker or dispatch it using handler.</p> <p>Here is a simple <code>EventEmitter</code> usage:</p> <pre><code>from diator.events import EventMap, EventEmitter\nfrom diator.mediator import Mediator\n\n\nevent_map = EventMap()\nevent_map.bind(UserJoinedDomainEvent, UserJoinedDomainEventHandler)\nevent_map.bind(UserJoinedDomainEvent, AnotherUserJoinedDomainEventHandler)\n\nevent_emitter = EventEmitter(event_map=event_map, container=container)\nmediator = Mediator(\n    event_emitter=event_emitter,\n    request_map=request_map,\n    container=container\n)\n</code></pre>"},{"location":"events/#message-broker","title":"Message Broker","text":"<p>Diator supports several message brokers to publish Notification and ECST events. Supported message brokers:</p> <ul> <li>Redis Pub/Sub</li> <li>Azure Service Bus</li> </ul>"},{"location":"events/#redis","title":"Redis","text":"<p>To use Redis Pub/Sub as message broker, simply import it and put to <code>EventEmitter</code>:</p> <pre><code>from redis.asyncio import Redis\nfrom diator.events import EventMap, EventEmitter\nfrom diator.message_brokers.redis import RedisMessageBroker\n\n\nredis_client = Redis()\n\nmessage_broker = RedisMessageBroker(client=redis_client)\n\nevent_emitter = EventEmitter(\n    event_map=event_map, \n    container=container,\n    message_broker=message_broker\n)\n</code></pre> <p>As a result, it will produce events in the channel with default prefix <code>python_diator_channel</code>.</p> <p>Example of published event:</p> <pre><code>{\n\"message_type\":\"notification_event\",\n\"message_name\":\"UserJoinedNotificationEvent\",\n\"message_id\":\"9f62e977-73f7-462b-92cb-8ea658d3bcb5\",\n\"payload\":{\n\"event_id\":\"9f62e977-73f7-462b-92cb-8ea658d3bcb5\",\n\"event_timestamp\":\"2023-03-07T09:26:02.588855\",\n\"user_id\":123\n}\n}\n</code></pre> <p>Channel name:</p> <pre><code>python_diator_channel:notification_event:9f62e977-73f7-462b-92cb-8ea658d3bcb5\n</code></pre> <p>So, you can listen to specific event types by defining pattern of channel:</p> <pre><code>PSUBSCRIBE python_diator_channel:notification_event:*\n</code></pre>"},{"location":"events/#azure-service-bus","title":"Azure Service Bus","text":"<p>To use Azure Service Bus as message broker, simply import it and put to <code>EventEmitter</code>:</p> <pre><code>from azure.servicebus.aio import ServiceBusClient\nfrom diator.events import EventMap, EventEmitter\nfrom diator.message_brokers.azure import AzureMessageBroker\n\n\nazure_service_bus_client = ServiceBusClient.from_connection_string(\n    service_bus_connection_string\n)\nmessage_broker = AzureMessageBroker(\n    azure_service_bus_client,\n    topic_name,\n    timeout=15\n)\n\nevent_emitter = EventEmitter(\n    event_map=event_map, \n    container=container,\n    message_broker=message_broker\n)\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#minimal-example","title":"Minimal example","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass, field\n\nfrom di import Container, bind_by_type\nfrom di.dependent import Dependent\n\nfrom diator.container.di import DIContainer\nfrom diator.events import Event, EventEmitter, EventMap\nfrom diator.mediator import Mediator\nfrom diator.requests import Request, RequestHandler, RequestMap\n\n\n@dataclass(frozen=True, kw_only=True)\nclass JoinMeetingCommand(Request):\n    meeting_id: int\n    user_id: int\n    is_late: bool = field(default=False)\n\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meeting_api) -&gt; None:\n        self._meeting_api = meeting_api\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        self._meeting_api.join(request.meeting_id, request.user_id)\n        if request.is_late:\n            self._meeting_api.warn(request.user_id)\n\n\ndef setup_di() -&gt; DIContainer:\n    external_container = Container()\n\n    external_container.bind(\n        bind_by_type(\n            Dependent(JoinMeetingCommandHandler, scope=\"request\"),\n            JoinMeetingCommandHandler,\n        )\n    )\n\n    container = DIContainer()\n    container.attach_external_container(external_container)\n\n    return container\n\n\nasync def main() -&gt; None:\n    container = setup_di()\n\n    request_map = RequestMap()\n    request_map.bind(JoinMeetingCommand, JoinMeetingCommandHandler)\n\n    event_emitter = EventEmitter(event_map=EventMap(), container=container, message_broker=None)\n\n    mediator = Mediator(\n        request_map=request_map,\n        event_emitter=event_emitter,\n        container=container,\n    )\n\n    await mediator.send(JoinMeetingCommand(user_id=1, meeting_id=1, is_late=True))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#rodi-as-di-framework","title":"Rodi as di framework","text":"<pre><code>import asyncio\nimport logging\nfrom dataclasses import dataclass\n\nfrom redis import asyncio as redis\nfrom rodi import Container\n\nfrom diator.container.rodi import RodiContainer\nfrom diator.events import (\n    DomainEvent,\n    EventEmitter,\n    EventHandler,\n    EventMap,\n    NotificationEvent,\n)\nfrom diator.mediator import Mediator\nfrom diator.message_brokers.redis import RedisMessageBroker\nfrom diator.middlewares import MiddlewareChain\nfrom diator.middlewares.logging import LoggingMiddleware\nfrom diator.requests import Request, RequestHandler, RequestMap\n\n\n@dataclass(frozen=True, kw_only=True)\nclass JoinMeetingRoomCommand(Request):\n    user_id: int\n\n\n@dataclass(frozen=True, kw_only=True)\nclass UserJoinedDomainEvent(DomainEvent):\n    user_id: int\n\n\n@dataclass(frozen=True, kw_only=True)\nclass UserJoinedNotificationEvent(NotificationEvent):\n    user_id: int\n\n\nclass JoinMeetingRoomCommandHandler(RequestHandler[JoinMeetingRoomCommand, None]):\n    def __init__(self) -&gt; None:\n        self._events = []\n\n    @property\n    def events(self) -&gt; list:\n        return self._events\n\n    async def handle(self, request: JoinMeetingRoomCommand) -&gt; None:\n        self._events.append(UserJoinedDomainEvent(user_id=request.user_id))\n        self._events.append(UserJoinedNotificationEvent(user_id=123))\n\n\nclass UserJoinedEventHandler(EventHandler[UserJoinedDomainEvent]):\n    async def handle(self, event: UserJoinedDomainEvent) -&gt; None:\n        print(\"READY\", event)\n\n\ndef configure_di() -&gt; RodiContainer:\ncontainer = Container()\ncontainer.register(UserJoinedEventHandler)\ncontainer.register(JoinMeetingRoomCommandHandler)\nrodi_container = RodiContainer()\nrodi_container.attach_external_container(container)\nreturn rodi_container\nclass FirstMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before 1 handling...\")\n        response = await handle(request)\n        print(\"After 1 handling...\")\n        return response\n\n\nclass SecondMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before 2  handling...\")\n        response = await handle(request)\n        print(\"After 2 handling...\")\n        return response\n\n\nasync def main() -&gt; None:\n    logging.basicConfig(level=logging.DEBUG)\n\n    middleware_chain = MiddlewareChain()\n    middleware_chain.add(LoggingMiddleware())\n    middleware_chain.add(FirstMiddleware())\n    middleware_chain.add(SecondMiddleware())\n    event_map = EventMap()\n    event_map.bind(UserJoinedDomainEvent, UserJoinedEventHandler)\n    request_map = RequestMap()\n    request_map.bind(JoinMeetingRoomCommand, JoinMeetingRoomCommandHandler)\n    container = configure_di()\n\n    redis_client = redis.Redis.from_url(\"redis://localhost:6379/0\")\n\n    event_emitter = EventEmitter(\n        message_broker=RedisMessageBroker(redis_client),\n        event_map=event_map,\n        container=container,\n    )\n\n    mediator = Mediator(\n        request_map=request_map,\n        event_emitter=event_emitter,\n        container=container,\n        middleware_chain=middleware_chain,\n    )\n\n    await mediator.send(JoinMeetingRoomCommand(user_id=1))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#di-lib-as-di-framework","title":"DI-lib as di framework","text":"<pre><code>import asyncio\nfrom dataclasses import dataclass\n\nfrom di import Container, bind_by_type\nfrom di.dependent import Dependent\nfrom redis import asyncio as redis\n\nfrom diator.container.di import DIContainer\nfrom diator.events import (\n    DomainEvent,\n    EventEmitter,\n    EventHandler,\n    EventMap,\n    NotificationEvent,\n)\nfrom diator.mediator import Mediator\nfrom diator.message_brokers.redis import RedisMessageBroker\nfrom diator.middlewares import MiddlewareChain\nfrom diator.requests import Request, RequestHandler, RequestMap\n\n\n@dataclass(frozen=True, kw_only=True)\nclass JoinMeetingRoomCommand(Request):\n    user_id: int\n\n\n@dataclass(frozen=True, kw_only=True)\nclass UserJoinedDomainEvent(DomainEvent):\n    user_id: int\n\n\n@dataclass(frozen=True, kw_only=True)\nclass UserJoinedNotificationEvent(NotificationEvent):\n    user_id: int\n\n\nclass JoinMeetingRoomCommandHandler(RequestHandler[JoinMeetingRoomCommand, None]):\n    def __init__(self) -&gt; None:\n        self._events = []\n\n    @property\n    def events(self) -&gt; list:\n        return self._events\n\n    async def handle(self, request: JoinMeetingRoomCommand) -&gt; None:\n        self._events.append(UserJoinedDomainEvent(user_id=request.user_id))\n        self._events.append(UserJoinedNotificationEvent(user_id=123))\n\n\nclass UserJoinedEventHandler(EventHandler[UserJoinedDomainEvent]):\n    async def handle(self, event: UserJoinedDomainEvent) -&gt; None:\n        print(\"READY\", event)\n\n\nclass FirstMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before 1 handling...\")\n        response = await handle(request)\n        print(\"After 1 handling...\")\n        return response\n\n\nclass SecondMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before 2  handling...\")\n        response = await handle(request)\n        print(\"After 2 handling...\")\n        return response\n\n\ndef configure_di() -&gt; DIContainer:\ncontainer = Container()\ncontainer.bind(bind_by_type(Dependent(UserJoinedEventHandler, scope=\"request\"), UserJoinedEventHandler))\ncontainer.bind(\nbind_by_type(\nDependent(JoinMeetingRoomCommandHandler, scope=\"request\"),\nJoinMeetingRoomCommandHandler,\n)\n)\ndi_container = DIContainer()\ndi_container.attach_external_container(container)\nreturn di_container\nasync def main() -&gt; None:\n    middleware_chain = MiddlewareChain()\n    middleware_chain.add(FirstMiddleware())\n    middleware_chain.add(SecondMiddleware())\n    event_map = EventMap()\n    event_map.bind(UserJoinedDomainEvent, UserJoinedEventHandler)\n    request_map = RequestMap()\n    request_map.bind(JoinMeetingRoomCommand, JoinMeetingRoomCommandHandler)\n    container = configure_di()\n\n    redis_client: redis.Redis = redis.Redis.from_url(\"redis://localhost:6379/0\")\n\n    event_emitter = EventEmitter(\n        message_broker=RedisMessageBroker(redis_client),\n        event_map=event_map,\n        container=container,\n    )\n\n    mediator = Mediator(\n        request_map=request_map,\n        event_emitter=event_emitter,\n        container=container,\n        middleware_chain=middleware_chain,\n    )\n\n    await mediator.send(JoinMeetingRoomCommand(user_id=1))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"examples/#azure-service-bus","title":"Azure Service Bus","text":"<pre><code>import asyncio\nimport os\nfrom dataclasses import dataclass\nfrom datetime import timedelta\n\nimport rodi\nfrom azure.servicebus.aio import ServiceBusClient\n\nfrom diator.container.rodi import RodiContainer\nfrom diator.events import EventEmitter, EventMap, NotificationEvent\nfrom diator.mediator import Mediator\nfrom diator.message_brokers.azure import AzureMessageBroker\nfrom diator.requests import Request, RequestHandler, RequestMap\n\n\n@dataclass(frozen=True, kw_only=True)\nclass CleanUnactiveUsersCommand(Request):\n    eta: timedelta\n\n\n@dataclass(frozen=True, kw_only=True)\nclass UnactiveUsersCleaned(NotificationEvent):\n    ids: list\n\n\nclass CleanUnactiveUsersCommandHandler(RequestHandler[CleanUnactiveUsersCommand, None]):\n    def __init__(self) -&gt; None:\n        self._events = []\n\n    @property\n    def events(self) -&gt; list:\n        return self._events\n\n    async def handle(self, request: CleanUnactiveUsersCommand) -&gt; None:\n        self._events.append(UnactiveUsersCleaned(ids=[1, 2, 3, 4, 5]))\n\n\ndef configure_di() -&gt; RodiContainer:\n    external_container = rodi.Container()\n    external_container.register(CleanUnactiveUsersCommandHandler)\n\n    container = RodiContainer()\n    container.attach_external_container(external_container)\n    return container\n\n\nasync def main() -&gt; None:\n    service_bus_connection_string = os.getenv(\"CONNECTION_STRING\")\n    topic_name = os.getenv(\"TOPIC_NAME\")\n\n    container = configure_di()\n    request_map = RequestMap()\n    request_map.bind(CleanUnactiveUsersCommand, CleanUnactiveUsersCommandHandler)\n\nazure_service_bus_client = ServiceBusClient.from_connection_string(service_bus_connection_string)\nmessage_broker = AzureMessageBroker(azure_service_bus_client, topic_name, timeout=15)\nevent_emitter = EventEmitter(message_broker=message_broker, event_map=EventMap(), container=container)\nmediator = Mediator(event_emitter=event_emitter, request_map=request_map, container=container)\n\n    await mediator.send(CleanUnactiveUsersCommand(eta=timedelta(days=1)))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"introduction/","title":"Introduction","text":""},{"location":"introduction/#diator-cqrs-library-for-python","title":"Diator - CQRS Library for Python","text":"<p>Diator is a Python library for implementing CQRS pattern in your Python applications. It provides a set of abstractions and utilities to help you separate your read and write concerns, allowing for better scalability, performance, and maintainability of your application.</p>"},{"location":"introduction/#features","title":"Features","text":"<ul> <li>Implements the CQRS pattern.</li> <li>Simple, yet flexible API.</li> <li>Supports multiple message brokers, such as Redis Pub/Sub and Azure Service Bus.</li> <li>Supports various di-frameworks, such as di and rodi.</li> <li>Easy to integrate with existing codebases.</li> </ul>"},{"location":"introduction/#installation","title":"Installation","text":"<p>Install the Diator library with pip</p> <pre><code>pip install diator\n</code></pre> <p>There are also several installation options:</p> <ul> <li> <p>To use Redis as Message Broker</p> <pre><code>pip install diator[redis]\n</code></pre> </li> <li> <p>Or Azure Service Bus</p> <pre><code>pip install diator[azure]\n</code></pre> </li> </ul>"},{"location":"introduction/#simple-example","title":"Simple Example","text":"<p>Minimal example of diator usage:</p> <pre><code>import asyncio\nfrom dataclasses import dataclass, field\nfrom di import Container, bind_by_type\nfrom di.dependent import Dependent\nfrom diator.events import EventMap, Event, EventEmitter\nfrom diator.container.di import DIContainer\nfrom diator.mediator import Mediator\nfrom diator.requests import Request, RequestHandler, RequestMap\n\n\n@dataclass(frozen=True, kw_only=True)\nclass JoinMeetingCommand(Request):\n    meeting_id: int\n    user_id: int\n    is_late: bool = field(default=False)\n\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meeting_api) -&gt; None:\n        self._meeting_api = meeting_api\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        self._meeting_api.join(request.meeting_id, request.user_id)\n        if request.is_late:\n            self._meeting_api.warn(request.user_id)\n\n\ndef setup_di() -&gt; DIContainer:\n    external_container = Container()\n\n    external_container.bind(\n        bind_by_type(\n            Dependent(JoinMeetingCommandHandler, scope=\"request\"),\n            JoinMeetingCommandHandler,\n        )\n    )\n\n    container = DIContainer()\n    container.attach_external_container(external_container)\n\n    return container\n\n\nasync def main() -&gt; None:\n    container = setup_di()\n\n    request_map = RequestMap()\n    request_map.bind(JoinMeetingCommand, JoinMeetingCommandHandler)\n\n    event_emitter = EventEmitter(\n        event_map=EventMap(), container=container, message_broker=None\n    )\n\n    mediator = Mediator(\n        request_map=request_map,\n        event_emitter=event_emitter,\n        container=container,\n    )\n\n    await mediator.send(JoinMeetingCommand(user_id=1, meeting_id=1, is_late=True))\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"introduction/#further-reading","title":"Further reading","text":"<ul> <li>Udi Dahan - Clarified CQRS</li> <li>Martin Fowler - CQRS</li> <li>Marting Fowler - What do you mean by \u201cEvent-Driven\u201d?</li> <li>Vlad Khononov - Learning Domain-Driven Design</li> <li>Vaughn Vernon - Really Simple CQRS</li> </ul>"},{"location":"introduction/#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"middlewares/","title":"Middlewares","text":"<p>A middleware is a component that wraps request handler in order to observe or change its behavior.</p>"},{"location":"middlewares/#usage","title":"Usage","text":"<p>Generally, your middleware should match the following protocol:</p> <pre><code>class Middleware(Protocol):\n    async def __call__(self, request: Request, handle: HandleType) -&gt; Res:\n        ...\n</code></pre> <p>The simplest sample:</p> <pre><code>class SampleMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before handle: \", request)\n        response = await handle(request)\n        print(\"After handle: \", response)\n</code></pre>"},{"location":"middlewares/#middleware-chain","title":"Middleware chain","text":"<p>A middleware chain is a crucial component that serves as a storage for your middlewares. It simplifies the interaction between middleware and request handlers.</p> <p>Usage:</p> <pre><code>from diator.middlewares import MiddlewareChain\n\n\nclass FirstMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before 1 handling...\")\n        response = await handle(request)\n        print(\"After 1 handling...\")\n        return response\n\n\nclass SecondMiddleware:\n    async def __call__(self, request: Request, handle):\n        print(\"Before 2  handling...\")\n        response = await handle(request)\n        print(\"After 2 handling...\")\n        return response\n\n\nmiddleware_chain = MiddlewareChain()\nmiddleware_chain.add(FirstMiddleware())\nmiddleware_chain.add(SecondMiddleware())\n\nmediator = Mediator(\n    request_map=request_map,\n    container=container,\n    middleware_chain=middleware_chain,\n)\n</code></pre> <p>Output will be the following:</p> <pre><code>Before 1 handling...\nBefore 2  handling...\nAfter 2 handling...\nAfter 1 handling...\n</code></pre>"},{"location":"middlewares/#built-in-middlewares","title":"Built-in middlewares","text":"<p>We plan to provide several middlewares for common use cases. Currently, only logging middleware is implemented.</p>"},{"location":"middlewares/#logging","title":"Logging","text":"<p>Simply import it:</p> <pre><code>from diator.middlewares import LoggingMiddleware\n</code></pre> <p>And then add it to the <code>MiddlewareChain</code>:</p> <pre><code>from diator.middlewares import MiddlewareChain\nfrom diator.middlewares.logging import LoggingMiddleware\n\n\nchain = MiddlewareChain()\nchain.add(LoggingMiddleware())\n</code></pre> <p>Result:</p> <pre><code>DEBUG:diator.middlewares.logging:Request JoinMeetingRoomCommand handled. Response: None\nDEBUG:diator.events.event_emitter:Sending Notification Event(a9aab9b3-6a40-4caa-ba63-93d3f92bb11b) to message broker RedisMessageBroker\nDEBUG:diator.message_brokers.redis:Sending message to Redis Pub/Sub a9aab9b3-6a40-4caa-ba63-93d3f92bb11b.\nDEBUG:diator.events.event_emitter:Handling Event(UserJoinedDomainEvent) via event handler(UserJoinedEventHandler)\n</code></pre>"},{"location":"requests/","title":"Requests","text":"<p>This section will guide you to the way of working with requests and responses.</p> <p>There are two types of requests in the CQRS: <code>Command</code>, <code>Query</code>.</p>"},{"location":"requests/#command","title":"Command","text":"<p>Command represents an intention to perform an action or change the state of an application. Here is an example of the Command:</p> <pre><code>from diator.requests import Request\nfrom diator.response import Response\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass JoinMeetingCommand(Request)\n    meeting_id: int = dataclasses.field(default=1)\n    user_id: int = dataclasses.field(default=1)\n</code></pre> <p>We define <code>frozen=True</code>, since all requests should be immutable by definition.</p>"},{"location":"requests/#command-handler","title":"Command Handler","text":"<p>Command Handler is a component responsible for handling a Command and executing the corresponding action:</p> <pre><code>from diator.requests import RequestHandler\nfrom diator.events import EventHandler\n\n\nclass JoinMeetingCommandHandler(RequestHandler[JoinMeetingCommand, None]):\n    def __init__(self, meeting_api: MeetingAPI) -&gt; None:\n        self._meeting_api = meeting_api\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: JoinMeetingCommand) -&gt; None:\n        await self._meeting_api.join(request.meeting_id, request.user_id)\n</code></pre>"},{"location":"requests/#query","title":"Query","text":"<p>Query represents a request for information or data from the application's read model. The process of handling queries SHOULD NOT modify the state of the application:</p> <pre><code>from diator.requests import Request\n\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ReadMeetingQuery(Request)\n    meeting_id: int = dataclasses.field(default=1)\n</code></pre>"},{"location":"requests/#query-result","title":"Query Result","text":"<p>Query Result is an object that contains the data requested by a Query. It is returned by a Query Handler after it processes a Query against the read model:</p> <pre><code>from diator.response import Response\n\n@dataclasses.dataclass(frozen=True, kw_only=True)\nclass ReadMeetingQueryResult(Response)\n    meeting_id: int = dataclasses.field(default=1)\n    link: str = dataclasses.field()\n</code></pre>"},{"location":"requests/#query-handler","title":"Query Handler","text":"<p>Query Handler is a component responsible for processing a Query against the read model and returning the requested data as a Query Result:</p> <pre><code>from diator.requests import RequestHandler\n\n\nclass ReadMeetingQueryHandler(RequestHandler[ReadMeetingQuery, ReadMeetingQueryResult]):\n    def __init__(self, meeting_api: MeetingAPI) -&gt; None:\n        self._meeting_api = meeting_api\n        self._events: list[Event] = []\n\n    @property\n    def events(self) -&gt; list[Event]:\n        return self._events\n\n    async def handle(self, request: ReadMeetingQuery) -&gt; ReadMeetingQueryResult:\n        link = await self._meeting_api.get_link(request.meeting_id)\n        return ReadMeetingQueryResult(\n            meeting_id=request.meeting_id,\n            link=link\n        )\n</code></pre>"},{"location":"requests/#mapping","title":"Mapping","text":"<p>In order to map each request to its handler, you can use <code>RequestMap</code> as below:</p> <pre><code>from diator.requests import RequestMap\n\n\nrequest_map = RequestMap()\nrequest_map.bind(JoinMeetingCommand, JoinMeetingCommandHandler)\nrequest_map.bind(ReadMeetingQuery, ReadMeetingQueryHandler)\n</code></pre> <p>And then, put it to <code>Mediator</code>:</p> <pre><code>from diator.mediator import Mediator\nfrom diator.requests import RequestMap\n\n\nrequest_map = RequestMap()\nrequest_map.bind(JoinMeetingCommand, JoinMeetingCommandHandler)\nrequest_map.bind(ReadMeetingQuery, ReadMeetingQueryHandler)\n\nmediator = Mediator(request_map=request_map, container=container)\n</code></pre>"}]}